var sys = require('sys');

ometa CssSelector <: Parser {
  crChar = '\r',
  ffChar = '\f',
  nlChar = '\n',
  tabChar = '\t',
  lineEnding = crChar | ffChar | nlChar,
  tabOrLineEnding = tabChar | lineEnding,


  ident = '-' nmstart:s nmchar*:cs -> { '-' + s + cs.join('') } 
        | nmstart:s nmchar*:cs -> { s + cs.join('') },
  name = nmchar+:n -> { n.join('') },
  nmstart = ('_' | letter | nonascii | escape):n -> { n },
  nonascii = '',
  unicode = '',
  escape = unicode | '',
  nmchar = '_' | '-' | letterOrDigit | nonascii | escape,
  num = digit+: d -> d.join('')
      | digit* '.' digit+,
  string = (string1 | string2):s -> { s },
  //string1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*:s '\"' -> { '\"' + s.join('') + '\"' },
  string1 = '"' letter*:s '"' -> { '"' + s.join('') + '"' },
  string2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*:s '\'' -> { '\'' + s.join('') + '\'' },
  //invalid = invalid1 | invalid2,
  //invalid1 = '\"' (~(lineEnding | '\"') | '\\' nl | nonascii | escape)*,
  //invalid2 = '\'' (~(lineEnding | '\'') | '\\' nl | nonascii | escape)*,
  nl = crChar nlChar
     | lineEnding,
  w = (' ' | tabOrLineEnding)*,
  D = 'd' | 'D',
  E = 'e' | 'E',
  N = 'n' | 'N',
  O = 'o' | 'O',
  T = 't' | 'T',
  V = 'v' | 'V',


  S = ' ' | tabOrLineEnding,
  INCLUDES = '~' '=' -> { '~=' },
  DASHMATCH = '|' '=' -> { '|=' },
  PREFIXMATCH = '^' '=' -> { '^=' },
  SUFFIXMATCH = '$' '=' -> { '$=' },
  SUBSTRINGMATCH = '*' '=' -> { '*=' },
  IDENT = ident,
  STRING = string:s -> { s },
  FUNCTION = ident:i '(' -> { i + '(' },
  NUMBER = num:n -> { n },
  HASH = '#' name:n -> { '#' + n },
  PLUS = '+' -> { '+' }
       | w '+' -> { ' +' },
  GREATER = w '>' -> { ' >' },
  COMMA = w ',' -> { ' ,' },
  TILDE = w '~' -> { ' ~' },
  NOT = ':' N O T '(',
  ATKEYWORD = '@' ident,
  INVALID = invalid,
  PERCENTAGE = num '%',
  DIMENSION = num:n ident:i -> { n + i },
  CDO = '<' '!' '-' '-',
  CDC = '-' '-' '>',


  selectors_group = selector:s (COMMA S* selector)* -> { self.add(s); self },
  selector = simple_selector_sequence:sim (combined_sequence)*:additional -> { sim + additional.join('') },
  combinator = PLUS:p S+ -> { p + ' ' }
             | PLUS:p -> { p }
             | GREATER:g S+ -> { g + ' ' }
             | GREATER:g -> { g }
             | TILDE:t S+ -> { t + ' ' }
             | TILDE:t -> { t }
             | S+ -> { ' ' },
  combined_sequence = combinator:comb simple_selector_sequence:sel -> { comb + sel },
  simple_selector_sequence = (type_selector | universal):pre (HASH | class | attrib | pseudo | negation)*:post -> { pre + post.join('') }
                           | (HASH | class | attrib | pseudo | negation)+:sels -> { sels.join('') },
  type_selector = namespace_prefix element_name
                | element_name:ele -> { ele },
  namespace_prefix = (IDENT | '*') '|'
                   | '|',
  element_name = IDENT:i -> { i },
  universal = namespace_prefix '*'
            | '*',
  class = '.' IDENT:i -> { '.' + i },

  attrib = '[' S* possible_namespaced_attrib:att ']' -> { '[' + att + ']' },
  possible_namespaced_attrib = namespace_prefix:pre ident_with_possible_postfix:post -> { pre + post }
                             | ident_with_possible_postfix:post -> { post },
  ident_with_possible_postfix = IDENT:left S* attrib_match:match S* (IDENT | STRING):right S* -> { left + match + right }
                              | IDENT:i S* -> { i },
  attrib_match = (PREFIXMATCH | SUFFIXMATCH | SUBSTRINGMATCH | equals_match | INCLUDES | DASHMATCH):m -> { m },
  equals_match = '=' -> { '=' },
  pseudo = ':' ':' (functional_pseudo | IDENT):i -> { '::' + i }
         | ':' (functional_pseudo | IDENT):i -> { ':' + i },
  functional_pseudo = FUNCTION:f S* full_expression:e ')' -> { f + e + ')' },

  expression_content = (PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT):e -> { e },
  expression = expression_content:ec S+ expression:e -> { ec + ' ' + e }
             | expression_content:ec expression:e -> { ec + e }
             | expression_content:ec S* -> { ec },
  full_expression = (expression)+:ea -> { ea.join('') },
  negation = NOT S* negation_arg S* ')',
  negation_arg = type_selector | universal | HASH | class | attrib | pseudo
}

CssSelector.initialize = function() {
  var s;
  
  this.toString = function() {
    return s;
  };

  this.add = function(st) {
    s = st;
  };
};

CssSelector
